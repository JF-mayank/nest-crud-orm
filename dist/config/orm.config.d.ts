/// <reference types="node" />
import { ConfigModule, ConfigService } from '@nestjs/config';
export declare const typeOrmModuleOptions: {
    imports: (typeof ConfigModule)[];
    inject: (typeof ConfigService)[];
    useFactory: (configService: ConfigService) => {
        retryAttempts?: number;
        retryDelay?: number;
        toRetry?: (err: any) => boolean;
        autoLoadEntities?: boolean;
        keepConnectionAlive?: boolean;
        verboseRetryLog?: boolean;
        manualInitialization?: boolean;
        type?: "postgres";
        schema?: string;
        driver?: any;
        nativeDriver?: any;
        useUTC?: boolean;
        replication?: {
            readonly master: import("typeorm/driver/postgres/PostgresConnectionCredentialsOptions").PostgresConnectionCredentialsOptions;
            readonly slaves: import("typeorm/driver/postgres/PostgresConnectionCredentialsOptions").PostgresConnectionCredentialsOptions[];
            readonly defaultMode?: import("typeorm").ReplicationMode;
        };
        connectTimeoutMS?: number;
        uuidExtension?: "pgcrypto" | "uuid-ossp";
        poolErrorHandler?: (err: any) => any;
        logNotifications?: boolean;
        installExtensions?: boolean;
        parseInt8?: boolean;
        name?: string;
        entities?: import("typeorm").MixedList<string | Function | import("typeorm").EntitySchema<any>>;
        subscribers?: import("typeorm").MixedList<string | Function>;
        migrations?: import("typeorm").MixedList<string | Function>;
        migrationsTableName?: string;
        migrationsTransactionMode?: "all" | "none" | "each";
        metadataTableName?: string;
        namingStrategy?: import("typeorm").NamingStrategyInterface;
        logging?: import("typeorm").LoggerOptions;
        logger?: "advanced-console" | "simple-console" | "file" | "debug" | import("typeorm").Logger;
        maxQueryExecutionTime?: number;
        poolSize?: number;
        synchronize?: boolean;
        migrationsRun?: boolean;
        dropSchema?: boolean;
        entityPrefix?: string;
        entitySkipConstructor?: boolean;
        extra?: any;
        relationLoadStrategy?: "join" | "query";
        typename?: string;
        cache?: boolean | {
            readonly type?: "database" | "redis" | "ioredis" | "ioredis/cluster";
            readonly provider?: (connection: import("typeorm").DataSource) => import("typeorm/cache/QueryResultCache").QueryResultCache;
            readonly tableName?: string;
            readonly options?: any;
            readonly alwaysEnabled?: boolean;
            readonly duration?: number;
            readonly ignoreErrors?: boolean;
        };
        isolateWhereStatements?: boolean;
        url?: string;
        host?: string;
        port?: number;
        username?: string;
        password?: string | (() => string) | (() => Promise<string>);
        database?: string;
        ssl?: boolean | import("tls").TlsOptions;
        applicationName?: string;
        imports: (typeof ConfigModule)[];
        inject: (typeof ConfigService)[];
        useFactory: any;
    };
};
export declare const OrmConfig: {
    migrationsTableName: string;
    migrations: string[];
    cli: {
        migrationsDir: string;
    };
    imports: (typeof ConfigModule)[];
    inject: (typeof ConfigService)[];
    useFactory: (configService: ConfigService) => {
        retryAttempts?: number;
        retryDelay?: number;
        toRetry?: (err: any) => boolean;
        autoLoadEntities?: boolean;
        keepConnectionAlive?: boolean;
        verboseRetryLog?: boolean;
        manualInitialization?: boolean;
        type?: "postgres";
        schema?: string;
        driver?: any;
        nativeDriver?: any;
        useUTC?: boolean;
        replication?: {
            readonly master: import("typeorm/driver/postgres/PostgresConnectionCredentialsOptions").PostgresConnectionCredentialsOptions;
            readonly slaves: import("typeorm/driver/postgres/PostgresConnectionCredentialsOptions").PostgresConnectionCredentialsOptions[];
            readonly defaultMode?: import("typeorm").ReplicationMode;
        };
        connectTimeoutMS?: number;
        uuidExtension?: "pgcrypto" | "uuid-ossp";
        poolErrorHandler?: (err: any) => any;
        logNotifications?: boolean;
        installExtensions?: boolean;
        parseInt8?: boolean;
        name?: string;
        entities?: import("typeorm").MixedList<string | Function | import("typeorm").EntitySchema<any>>;
        subscribers?: import("typeorm").MixedList<string | Function>;
        migrations?: import("typeorm").MixedList<string | Function>;
        migrationsTableName?: string;
        migrationsTransactionMode?: "all" | "none" | "each";
        metadataTableName?: string;
        namingStrategy?: import("typeorm").NamingStrategyInterface;
        logging?: import("typeorm").LoggerOptions;
        logger?: "advanced-console" | "simple-console" | "file" | "debug" | import("typeorm").Logger;
        maxQueryExecutionTime?: number;
        poolSize?: number;
        synchronize?: boolean;
        migrationsRun?: boolean;
        dropSchema?: boolean;
        entityPrefix?: string;
        entitySkipConstructor?: boolean;
        extra?: any;
        relationLoadStrategy?: "join" | "query";
        typename?: string;
        cache?: boolean | {
            readonly type?: "database" | "redis" | "ioredis" | "ioredis/cluster";
            readonly provider?: (connection: import("typeorm").DataSource) => import("typeorm/cache/QueryResultCache").QueryResultCache;
            readonly tableName?: string;
            readonly options?: any;
            readonly alwaysEnabled?: boolean;
            readonly duration?: number;
            readonly ignoreErrors?: boolean;
        };
        isolateWhereStatements?: boolean;
        url?: string;
        host?: string;
        port?: number;
        username?: string;
        password?: string | (() => string) | (() => Promise<string>);
        database?: string;
        ssl?: boolean | import("tls").TlsOptions;
        applicationName?: string;
        imports: (typeof ConfigModule)[];
        inject: (typeof ConfigService)[];
        useFactory: any;
    };
};
export default OrmConfig;
